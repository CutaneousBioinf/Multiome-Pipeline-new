---
title: "Multiome Process3"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: pdf_document
---

This R script will do the peak recalling, batch correction and process cluster markers, it requires 4 inputs: 'after_QC.RDS', directory of macs2, ATAC_seq, and 'annotations.RDS'. After running, 'after_link_peaks.RDS' and 'cluster_markers.RDS' will be saved for cell type annotation and following analysis. 

```{r,echo=F,message=F,warning=F}
library(Seurat)
library(Signac)
library(EnsDb.Hsapiens.v86)
library(dplyr)
library(ggplot2)
library(SoupX)
library(Matrix)
library(scDblFinder)
library(SeuratData)
library(SeuratDisk)
library(harmony)
library(BSgenome.Hsapiens.UCSC.hg38)
library(chromVAR)
library(JASPAR2020)
library(TFBSTools)
library(motifmatchr)
library(stringr)
library(gridExtra)
library(grid)
library(yaml)
library(config)

config = yaml.load_file("config.yml")
Sys.setenv(R_CONFIG_ACTIVE = "default")
dir_after_QC = config::get("dir_after_QC")
dir_macs2= config::get("dir_macs2")
dir_annotations= config::get("dir_annotations")
dir_ATAC = config::get("dir_ATAC")
output_dir = config::get("output_dir")
```


## Peak Recalling

The set of peaks identified using Cellranger often merges distinct peaks that are close together. This can create a problem for certain analyses, particularly motif enrichment analysis and peak-to-gene linkage. To identify a more accurate set of peaks, we can call peaks using MACS2. Here we call peaks on all cells together, but we could identify peaks for each group of cells separately by setting the 'group.by' parameter, and this can help identify peaks specific to rare cell populations.


```{r,echo=F,message=F,warning=F}
SSc.gene.multiome.seurat.filtered <- readRDS(dir_after_QC)
annotations <- readRDS(dir_annotations)
frag.file <- dir_ATAC

DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "ATAC"
temp.peaks <- CallPeaks(SSc.gene.multiome.seurat.filtered, macs2.path = dir_macs2)

# remove peaks on nonstandard chromosomes and in genomic blacklist regions
temp.peaks <- keepStandardChromosomes(temp.peaks, pruning.mode = "coarse")
temp.peaks <- subsetByOverlaps(x = temp.peaks, ranges = blacklist_hg38_unified, invert = TRUE)

# quantify counts in each peak

temp.macs2.counts <- FeatureMatrix(fragments = Fragments(SSc.gene.multiome.seurat.filtered),  features = temp.peaks,  cells = colnames(SSc.gene.multiome.seurat.filtered))

# create a new assay using the MACS2 peak set and add it to the Seurat object

SSc.gene.multiome.seurat.filtered[["peaks"]] <- CreateChromatinAssay( counts = temp.macs2.counts,  fragments = frag.file,  annotation = annotations)
```


## Gene expression and DNA accessibility data processing 

We next perform normalization and pre-processing and dimensional reduction on both assays independently, using standard approaches for RNA and ATAC-seq data.

```{r,echo=F,message=F,warning=F}
# RNA analysis
DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "RNA"
SSc.gene.multiome.seurat.filtered <- SCTransform(SSc.gene.multiome.seurat.filtered, verbose = FALSE) %>% RunPCA() 

# ATAC analysis
# We exclude the first dimension as this is typically correlated with sequencing depth
DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "peaks"
SSc.gene.multiome.seurat.filtered <- RunTFIDF(SSc.gene.multiome.seurat.filtered)
SSc.gene.multiome.seurat.filtered <- FindTopFeatures(SSc.gene.multiome.seurat.filtered, min.cutoff = 'q0')
SSc.gene.multiome.seurat.filtered <- RunSVD(SSc.gene.multiome.seurat.filtered)
```


## Batch Correction

Batch correction was performed here.

```{r,echo=F,warning=F}

Idents(SSc.gene.multiome.seurat.filtered) = SSc.gene.multiome.seurat.filtered$batch 

DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "RNA"

SSc.gene.multiome.seurat.filtered =RunHarmony(SSc.gene.multiome.seurat.filtered, group.by.vars=c("batch"),reduction="pca", reduction.save= "harmony.pca",assay.use="SCT")

DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "peaks"

SSc.gene.multiome.seurat.filtered =RunHarmony(SSc.gene.multiome.seurat.filtered, group.by.vars=c("batch"),reduction="lsi", reduction.save= "harmony.lsi",assay.use="peaks", project.dim=F)

```


```{r,echo=F,message=F,warning=F}
### integrated

### We calculate a WNN graph, representing a weighted combination of RNA and ATAC-seq modalities. We use this graph for UMAP visualization and clustering

SSc.gene.multiome.seurat.filtered <- FindMultiModalNeighbors(SSc.gene.multiome.seurat.filtered, reduction.list = list("harmony.pca", "harmony.lsi"), dims.list = list(1:50, 2:50))

SSc.gene.multiome.seurat.filtered <- RunUMAP(SSc.gene.multiome.seurat.filtered, dims = 1:50, reduction.name = 'umap.harmony.pca',  reduction="harmony.pca")

SSc.gene.multiome.seurat.filtered <- RunUMAP(SSc.gene.multiome.seurat.filtered, dims = 1:50, reduction.name = 'umap.harmony.lsi',  reduction="harmony.lsi")

SSc.gene.multiome.seurat.filtered <- RunUMAP(SSc.gene.multiome.seurat.filtered, nn.name = "weighted.nn", reduction.name = "umap.harmony.wnn")

SSc.gene.multiome.seurat.filtered <- FindClusters(SSc.gene.multiome.seurat.filtered, graph.name = "wsnn", algorithm = 3, verbose = FALSE)

saveRDS(SSc.gene.multiome.seurat.filtered,file = paste(output_dir,'/','after_batch_correction.RDS', sep=""))
```



```{r,echo=F,message=F,warning=F}
### marker genes 
DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "SCT"

# This loop just runs the FindMarkers function on all of the clusters

SSc.gene.clustermarkers <- list()
Idents(SSc.gene.multiome.seurat.filtered) <- SSc.gene.multiome.seurat.filtered$seurat_clusters

for (i in levels(SSc.gene.multiome.seurat.filtered[["seurat_clusters"]][[1]])) {
  
  if ((length(which(SSc.gene.multiome.seurat.filtered$seurat_clusters == i)) > 3) &
  (length(which(SSc.gene.multiome.seurat.filtered$seurat_clusters != i)) > 3)) {
    
    SSc.gene.clustermarkers[[i]] <- FindMarkers(SSc.gene.multiome.seurat.filtered,ident.1 = i,min.pct = 0.1, test.use = "wilcox" , logfc.threshold=0.25, only.pos=T)
  
  }else{
    SSc.gene.clustermarkers[[i]] <- c()
  }
  
}

# lapply(
#   levels(SSc.gene.multiome.seurat.filtered[["seurat_clusters"]][[1]]),function(x)FindMarkers(SSc.gene.multiome.seurat.filtered,ident.1 = x,min.pct = 0.1, test.use = "wilcox" , logfc.threshold=0.25, only.pos=T)) -> SSc.gene.clustermarkers

saveRDS(SSc.gene.clustermarkers,file = paste(output_dir,'/','cluster_markers.RDS', sep=""))
```


```{r,echo=F,message=F,warning=F}
DefaultAssay(SSc.gene.multiome.seurat.filtered) <- "peaks"

# first compute the GC content for each peak
SSc.gene.multiome.seurat.filtered <- RegionStats(SSc.gene.multiome.seurat.filtered, genome = BSgenome.Hsapiens.UCSC.hg38)

# link peaks to genes
SSc.gene.multiome.seurat.filtered <- LinkPeaks(  object = SSc.gene.multiome.seurat.filtered,  peak.assay = "peaks",  expression.assay = "SCT")

saveRDS(SSc.gene.multiome.seurat.filtered,file = paste(output_dir,'/','after_link_peaks.RDS', sep=""))
```

#UMAP

```{r,echo=F,message=F,warning=F,fig.height=5, fig.width=13}

grid_arrange_shared_legend <- function(..., nrow = 1, ncol = length(list(...)), position = c("bottom", "right")) {

  plots <- list(...)
  position <- match.arg(position)
  g <- ggplotGrob(plots[[1]] + theme(legend.position = position))$grobs
  legend <- g[[which(sapply(g, function(x) x$name) == "guide-box")]]
  lheight <- sum(legend$height)
  lwidth <- sum(legend$width)
  gl <- lapply(plots, function(x) x + theme(legend.position = "none"))
  gl <- c(gl, nrow = nrow, ncol = ncol)

  combined <- switch(position,
                     "bottom" = arrangeGrob(do.call(arrangeGrob, gl),
                                            legend,
                                            ncol = 1,
                                            heights = unit.c(unit(1, "npc") - lheight, lheight)),
                     "right" = arrangeGrob(do.call(arrangeGrob, gl),
                                           legend,
                                           ncol = 2,
                                           widths = unit.c(unit(1, "npc") - lwidth, lwidth)))
  grid.newpage()
  grid.draw(combined)

}

p1 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.pca", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(paste("RNA (harmony)"))
p2 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.lsi", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(paste("ATAC (harmony)"))
p3 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.wnn", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle(paste("WNN (harmony)"))

grid_arrange_shared_legend(p1, p2, p3, nrow = 1, ncol = 3,position="right")

p1 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.pca", label = TRUE, label.size = 2.5, repel = TRUE, group.by= 'batch') + ggtitle(paste("RNA (harmony) by batch"))
p2 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.lsi", label = TRUE, label.size = 2.5, repel = TRUE, group.by= 'batch') + ggtitle(paste("ATAC (harmony) by batch"))
p3 <- DimPlot(SSc.gene.multiome.seurat.filtered, reduction = "umap.harmony.wnn", label = TRUE, label.size = 2.5, repel = TRUE, group.by= 'batch') + ggtitle(paste("WNN (harmony) by batch"))

grid_arrange_shared_legend(p1, p2, p3, nrow = 1, ncol = 3,position="right")
```













